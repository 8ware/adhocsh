#! /usr/bin/env python

from __future__ import print_function

import sys
import readline
from os import environ, path
from subprocess import call, check_output
from optparse import OptionParser
import shlex
import re


BASH_COMPLETION_DIR = '/usr/share/bash-completion/completions'

BASH_COMPLETION_SCRIPT_TEMPLATE = """
        # Source bash completion
        source "{completion_file:s}"

        # Prepare completion environment
        COMP_WORDS=( "{command:s}" "{quoted_args:s}" )
        COMP_CWORD={cword:d}

        # Execute completion
        {completion_function}

        # Print (return) completion results
        for match in "${{COMPREPLY[@]}}"; do
            echo "$match"
        done
"""


class AdHocShell(object):

    def __init__(self, command, completion, compfunc=None, default=None):
        self.command = command
        self.completion = completion
        self.completion_funcname = compfunc if compfunc else '_' + command
        self.default_subcommand = default

    def get_prompt(self):
        return self.command + '> '

    def complete(self, text, state):
        line = readline.get_line_buffer()
        args = line.split()
        if state == 0:  # On first trigger, build possible matches
            cword = len (args)
            # Try to complete next word (+1) if text is empty and separated
            # from the previous word by a whitespace
            cword += 0 if len (text) or len (line) and line[-1:] != ' ' else 1
            self.matches = self.get_bash_completion(args, cword)

        # Return match indexed by state
        try:
            match = self.matches[state]
            # Word Boundary Pattern
            wbp = re.compile('[ :=/]$') # See COMP_WORDBREAKS (git adds ':')
            if len (self.matches) == 1 and match and not wbp.search(match):
                match += ' '
            return match
        except IndexError:
            return None

    def display_matches(self, substitution, matches, longest_match_length):
        line_buffer = readline.get_line_buffer()
        columns = int (environ.get("COLUMNS", 80))

        print ()

        tpl = "{:<" + str(int(max(map(len, matches)) * 1.2)) + "}"

        buffer = ""
        for match in matches:
            match = tpl.format(match)
            if len(buffer + match) > columns:
                print(buffer.strip())
                buffer = ""
            buffer += match

        if buffer:
            print(buffer.strip())

        print(self.get_prompt(), end="")
        print(line_buffer, end="")
        sys.stdout.flush()

    def get_bash_completion(self, args, cword):
        script = BASH_COMPLETION_SCRIPT_TEMPLATE.format(
                completion_file = self.completion,
                command = self.command, quoted_args = '" "'.join(args),
                cword = cword, completion_function = self.completion_funcname)

        with open('/dev/null', 'w') as devnull:
            # Redirect STDERR to /dev/null since compopt complains to be not
            # in completion mode currently
            output = check_output([ 'bash', '-c', script ], stderr=devnull)

        matches = filter (None, output[:-1].split("\n"))

        return matches


parser = OptionParser()
parser.add_option('-d', '--default', action='store', dest='default', default=None)
parser.add_option('-f', '--compfunc', action='store', dest='compfunc', default=None)
parser.add_option('-D', '--no-default', action='store_false', dest='allow_default', default=True)
parser.add_option('-c', '--completion', action='store', dest='completion')
opts, args = parser.parse_args()

command = args[0]
completion = opts.completion if opts.completion else path.join(BASH_COMPLETION_DIR, command)

shell = AdHocShell(command, completion, compfunc=opts.compfunc, default=opts.default)
readline.set_completer_delims(' \t\n;:=')
readline.set_completer(shell.complete)
readline.parse_and_bind('tab: complete')
readline.set_completion_display_matches_hook(shell.display_matches)

print ("Ad-hoc shell for {}.".format(command))
print ("Hit Ctrl-D to leave!")

while True:
    try:
        line = raw_input(shell.get_prompt())
        args = shlex.split(line)
        argc = len (args)
        if not argc and not opts.allow_default:
            continue
        if not argc and shell.default_subcommand:
            args = [ shell.default_subcommand ]
        full_command = [ shell.command ]
        full_command.extend(args)
        call(full_command)
    except KeyboardInterrupt:
        print ('^C')
    except EOFError:
        print()
        break

